{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nlet FileDropDirective = /*#__PURE__*/(() => {\n  class FileDropDirective {\n    constructor(element) {\n      this.fileOver = new EventEmitter(); // eslint-disable-next-line @angular-eslint/no-output-on-prefix\n\n      this.onFileDrop = new EventEmitter();\n      this.element = element;\n    }\n\n    getOptions() {\n      var _a;\n\n      return (_a = this.uploader) === null || _a === void 0 ? void 0 : _a.options;\n    }\n\n    getFilters() {\n      return '';\n    }\n\n    onDrop(event) {\n      var _a;\n\n      const transfer = this._getTransfer(event);\n\n      if (!transfer) {\n        return;\n      }\n\n      const options = this.getOptions();\n      const filters = this.getFilters();\n\n      this._preventAndStop(event);\n\n      if (options) {\n        (_a = this.uploader) === null || _a === void 0 ? void 0 : _a.addToQueue(transfer.files, options, filters);\n      }\n\n      this.fileOver.emit(false);\n      this.onFileDrop.emit(transfer.files);\n    }\n\n    onDragOver(event) {\n      const transfer = this._getTransfer(event);\n\n      if (!this._haveFiles(transfer.types)) {\n        return;\n      }\n\n      transfer.dropEffect = 'copy';\n\n      this._preventAndStop(event);\n\n      this.fileOver.emit(true);\n    }\n\n    onDragLeave(event) {\n      if (this.element) {\n        if (event.currentTarget === this.element[0]) {\n          return;\n        }\n      }\n\n      this._preventAndStop(event);\n\n      this.fileOver.emit(false);\n    }\n\n    _getTransfer(event) {\n      return event.dataTransfer ? event.dataTransfer : event.originalEvent.dataTransfer; // jQuery fix;\n    }\n\n    _preventAndStop(event) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    _haveFiles(types) {\n      if (!types) {\n        return false;\n      }\n\n      if (types.indexOf) {\n        return types.indexOf('Files') !== -1;\n      } else if (types.contains) {\n        return types.contains('Files');\n      } else {\n        return false;\n      }\n    }\n\n  }\n\n  FileDropDirective.ɵfac = function FileDropDirective_Factory(t) {\n    return new (t || FileDropDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  FileDropDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FileDropDirective,\n    selectors: [[\"\", \"ng2FileDrop\", \"\"]],\n    hostBindings: function FileDropDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"drop\", function FileDropDirective_drop_HostBindingHandler($event) {\n          return ctx.onDrop($event);\n        })(\"dragover\", function FileDropDirective_dragover_HostBindingHandler($event) {\n          return ctx.onDragOver($event);\n        })(\"dragleave\", function FileDropDirective_dragleave_HostBindingHandler($event) {\n          return ctx.onDragLeave($event);\n        });\n      }\n    },\n    inputs: {\n      uploader: \"uploader\"\n    },\n    outputs: {\n      fileOver: \"fileOver\",\n      onFileDrop: \"onFileDrop\"\n    }\n  });\n  return FileDropDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass FileLikeObject {\n  constructor(fileOrInput) {\n    this.rawFile = fileOrInput;\n    const fakePathOrObject = fileOrInput instanceof HTMLInputElement ? fileOrInput.value : fileOrInput;\n    const postfix = typeof fakePathOrObject === 'string' ? 'FakePath' : 'Object';\n    const method = `_createFrom${postfix}`;\n    this[method](fakePathOrObject);\n  }\n\n  _createFromFakePath(path) {\n    this.lastModifiedDate = void 0;\n    this.size = void 0;\n    this.type = `like/${path.slice(path.lastIndexOf('.') + 1).toLowerCase()}`;\n    this.name = path.slice(path.lastIndexOf('/') + path.lastIndexOf('\\\\') + 2);\n  }\n\n  _createFromObject(object) {\n    this.size = object.size;\n    this.type = object.type;\n    this.name = object.name;\n  }\n\n}\n\nclass FileItem {\n  constructor(uploader, some, options) {\n    this.url = '/';\n    this.headers = [];\n    this.withCredentials = true;\n    this.formData = [];\n    this.isReady = false;\n    this.isUploading = false;\n    this.isUploaded = false;\n    this.isSuccess = false;\n    this.isCancel = false;\n    this.isError = false;\n    this.progress = 0;\n    this.uploader = uploader;\n    this.some = some;\n    this.options = options;\n    this.file = new FileLikeObject(some);\n    this._file = some;\n\n    if (uploader.options) {\n      this.method = uploader.options.method || 'POST';\n      this.alias = uploader.options.itemAlias || 'file';\n    }\n\n    this.url = uploader.options.url;\n  }\n\n  upload() {\n    try {\n      this.uploader.uploadItem(this);\n    } catch (e) {\n      this.uploader._onCompleteItem(this, '', 0, {});\n\n      this.uploader._onErrorItem(this, '', 0, {});\n    }\n  }\n\n  cancel() {\n    this.uploader.cancelItem(this);\n  }\n\n  remove() {\n    this.uploader.removeFromQueue(this);\n  }\n\n  onBeforeUpload() {\n    return void 0;\n  }\n\n  onBuildForm(form) {\n    return {\n      form\n    };\n  }\n\n  onProgress(progress) {\n    return {\n      progress\n    };\n  }\n\n  onSuccess(response, status, headers) {\n    return {\n      response,\n      status,\n      headers\n    };\n  }\n\n  onError(response, status, headers) {\n    return {\n      response,\n      status,\n      headers\n    };\n  }\n\n  onCancel(response, status, headers) {\n    return {\n      response,\n      status,\n      headers\n    };\n  }\n\n  onComplete(response, status, headers) {\n    return {\n      response,\n      status,\n      headers\n    };\n  }\n\n  _onBeforeUpload() {\n    this.isReady = true;\n    this.isUploading = true;\n    this.isUploaded = false;\n    this.isSuccess = false;\n    this.isCancel = false;\n    this.isError = false;\n    this.progress = 0;\n    this.onBeforeUpload();\n  }\n\n  _onBuildForm(form) {\n    this.onBuildForm(form);\n  }\n\n  _onProgress(progress) {\n    this.progress = progress;\n    this.onProgress(progress);\n  }\n\n  _onSuccess(response, status, headers) {\n    this.isReady = false;\n    this.isUploading = false;\n    this.isUploaded = true;\n    this.isSuccess = true;\n    this.isCancel = false;\n    this.isError = false;\n    this.progress = 100;\n    this.index = undefined;\n    this.onSuccess(response, status, headers);\n  }\n\n  _onError(response, status, headers) {\n    this.isReady = false;\n    this.isUploading = false;\n    this.isUploaded = true;\n    this.isSuccess = false;\n    this.isCancel = false;\n    this.isError = true;\n    this.progress = 0;\n    this.index = undefined;\n    this.onError(response, status, headers);\n  }\n\n  _onCancel(response, status, headers) {\n    this.isReady = false;\n    this.isUploading = false;\n    this.isUploaded = false;\n    this.isSuccess = false;\n    this.isCancel = true;\n    this.isError = false;\n    this.progress = 0;\n    this.index = undefined;\n    this.onCancel(response, status, headers);\n  }\n\n  _onComplete(response, status, headers) {\n    this.onComplete(response, status, headers);\n\n    if (this.uploader.options.removeAfterUpload) {\n      this.remove();\n    }\n  }\n\n  _prepareToUploading() {\n    this.index = this.index || ++this.uploader._nextIndex;\n    this.isReady = true;\n  }\n\n}\n\nlet FileType = /*#__PURE__*/(() => {\n  class FileType {\n    static getMimeClass(file) {\n      var _a, _b, _c;\n\n      let mimeClass = 'application';\n\n      if ((file === null || file === void 0 ? void 0 : file.type) && this.mime_psd.indexOf(file.type) !== -1) {\n        mimeClass = 'image';\n      } else if ((_a = file === null || file === void 0 ? void 0 : file.type) === null || _a === void 0 ? void 0 : _a.match('image.*')) {\n        mimeClass = 'image';\n      } else if ((_b = file === null || file === void 0 ? void 0 : file.type) === null || _b === void 0 ? void 0 : _b.match('video.*')) {\n        mimeClass = 'video';\n      } else if ((_c = file === null || file === void 0 ? void 0 : file.type) === null || _c === void 0 ? void 0 : _c.match('audio.*')) {\n        mimeClass = 'audio';\n      } else if ((file === null || file === void 0 ? void 0 : file.type) === 'application/pdf') {\n        mimeClass = 'pdf';\n      } else if ((file === null || file === void 0 ? void 0 : file.type) && this.mime_compress.indexOf(file.type) !== -1) {\n        mimeClass = 'compress';\n      } else if ((file === null || file === void 0 ? void 0 : file.type) && this.mime_doc.indexOf(file.type) !== -1) {\n        mimeClass = 'doc';\n      } else if ((file === null || file === void 0 ? void 0 : file.type) && this.mime_xsl.indexOf(file.type) !== -1) {\n        mimeClass = 'xls';\n      } else if ((file === null || file === void 0 ? void 0 : file.type) && this.mime_ppt.indexOf(file.type) !== -1) {\n        mimeClass = 'ppt';\n      }\n\n      if (mimeClass === 'application' && (file === null || file === void 0 ? void 0 : file.name)) {\n        mimeClass = this.fileTypeDetection(file.name);\n      }\n\n      return mimeClass;\n    }\n\n    static fileTypeDetection(inputFilename) {\n      const types = {\n        jpg: 'image',\n        jpeg: 'image',\n        tif: 'image',\n        psd: 'image',\n        bmp: 'image',\n        png: 'image',\n        nef: 'image',\n        tiff: 'image',\n        cr2: 'image',\n        dwg: 'image',\n        cdr: 'image',\n        ai: 'image',\n        indd: 'image',\n        pin: 'image',\n        cdp: 'image',\n        skp: 'image',\n        stp: 'image',\n        '3dm': 'image',\n        mp3: 'audio',\n        wav: 'audio',\n        wma: 'audio',\n        mod: 'audio',\n        m4a: 'audio',\n        compress: 'compress',\n        zip: 'compress',\n        rar: 'compress',\n        '7z': 'compress',\n        lz: 'compress',\n        z01: 'compress',\n        bz2: 'compress',\n        gz: 'compress',\n        pdf: 'pdf',\n        xls: 'xls',\n        xlsx: 'xls',\n        ods: 'xls',\n        mp4: 'video',\n        avi: 'video',\n        wmv: 'video',\n        mpg: 'video',\n        mts: 'video',\n        flv: 'video',\n        '3gp': 'video',\n        vob: 'video',\n        m4v: 'video',\n        mpeg: 'video',\n        m2ts: 'video',\n        mov: 'video',\n        doc: 'doc',\n        docx: 'doc',\n        eps: 'doc',\n        txt: 'doc',\n        odt: 'doc',\n        rtf: 'doc',\n        ppt: 'ppt',\n        pptx: 'ppt',\n        pps: 'ppt',\n        ppsx: 'ppt',\n        odp: 'ppt'\n      };\n      const chunks = inputFilename.split('.');\n\n      if (chunks.length < 2) {\n        return 'application';\n      }\n\n      const extension = chunks[chunks.length - 1].toLowerCase();\n\n      if (types[extension] === undefined) {\n        return 'application';\n      } else {\n        return types[extension];\n      }\n    }\n\n  }\n\n  /*  MS office  */\n  // tslint:disable-next-line:variable-name\n  FileType.mime_doc = ['application/msword', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.openxmlformats-officedocument.wordprocessingml.template', 'application/vnd.ms-word.document.macroEnabled.12', 'application/vnd.ms-word.template.macroEnabled.12']; // tslint:disable-next-line:variable-name\n\n  FileType.mime_xsl = ['application/vnd.ms-excel', 'application/vnd.ms-excel', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.openxmlformats-officedocument.spreadsheetml.template', 'application/vnd.ms-excel.sheet.macroEnabled.12', 'application/vnd.ms-excel.template.macroEnabled.12', 'application/vnd.ms-excel.addin.macroEnabled.12', 'application/vnd.ms-excel.sheet.binary.macroEnabled.12']; // tslint:disable-next-line:variable-name\n\n  FileType.mime_ppt = ['application/vnd.ms-powerpoint', 'application/vnd.ms-powerpoint', 'application/vnd.ms-powerpoint', 'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'application/vnd.openxmlformats-officedocument.presentationml.template', 'application/vnd.openxmlformats-officedocument.presentationml.slideshow', 'application/vnd.ms-powerpoint.addin.macroEnabled.12', 'application/vnd.ms-powerpoint.presentation.macroEnabled.12', 'application/vnd.ms-powerpoint.presentation.macroEnabled.12', 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12'];\n  /* PSD */\n  // tslint:disable-next-line:variable-name\n\n  FileType.mime_psd = ['image/photoshop', 'image/x-photoshop', 'image/psd', 'application/photoshop', 'application/psd', 'zz-application/zz-winassoc-psd'];\n  /* Compressed files */\n  // tslint:disable-next-line:variable-name\n\n  FileType.mime_compress = ['application/x-gtar', 'application/x-gcompress', 'application/compress', 'application/x-tar', 'application/x-rar-compressed', 'application/octet-stream', 'application/x-zip-compressed', 'application/zip-compressed', 'application/x-7z-compressed', 'application/gzip', 'application/x-bzip2'];\n  return FileType;\n})();\n\nfunction isFile(value) {\n  return File && value instanceof File;\n}\n\nclass FileUploader {\n  constructor(options) {\n    this.isUploading = false;\n    this.queue = [];\n    this.progress = 0;\n    this._nextIndex = 0;\n    this.options = {\n      autoUpload: false,\n      isHTML5: true,\n      filters: [],\n      removeAfterUpload: false,\n      disableMultipart: false,\n      formatDataFunction: item => item._file,\n      formatDataFunctionIsAsync: false,\n      url: ''\n    };\n    this.setOptions(options);\n    this.response = new EventEmitter();\n  }\n\n  setOptions(options) {\n    var _a, _b, _c, _d;\n\n    this.options = Object.assign(this.options, options);\n    this.authToken = this.options.authToken;\n    this.authTokenHeader = this.options.authTokenHeader || 'Authorization';\n    this.autoUpload = this.options.autoUpload;\n    (_a = this.options.filters) === null || _a === void 0 ? void 0 : _a.unshift({\n      name: 'queueLimit',\n      fn: this._queueLimitFilter\n    });\n\n    if (this.options.maxFileSize) {\n      (_b = this.options.filters) === null || _b === void 0 ? void 0 : _b.unshift({\n        name: 'fileSize',\n        fn: this._fileSizeFilter\n      });\n    }\n\n    if (this.options.allowedFileType) {\n      (_c = this.options.filters) === null || _c === void 0 ? void 0 : _c.unshift({\n        name: 'fileType',\n        fn: this._fileTypeFilter\n      });\n    }\n\n    if (this.options.allowedMimeType) {\n      (_d = this.options.filters) === null || _d === void 0 ? void 0 : _d.unshift({\n        name: 'mimeType',\n        fn: this._mimeTypeFilter\n      });\n    }\n\n    for (let i = 0; i < this.queue.length; i++) {\n      this.queue[i].url = this.options.url;\n    }\n  }\n\n  addToQueue(files, _options, filters) {\n    let options = _options;\n    const list = [];\n\n    for (const file of files) {\n      list.push(file);\n    }\n\n    const arrayOfFilters = this._getFilters(filters);\n\n    const count = this.queue.length;\n    const addedFileItems = [];\n    list.map(some => {\n      if (!options) {\n        options = this.options;\n      }\n\n      const temp = new FileLikeObject(some);\n\n      if (this._isValidFile(temp, arrayOfFilters, options)) {\n        const fileItem = new FileItem(this, some, options);\n        addedFileItems.push(fileItem);\n        this.queue.push(fileItem);\n\n        this._onAfterAddingFile(fileItem);\n      } else {\n        if (this._failFilterIndex) {\n          const filter = arrayOfFilters[this._failFilterIndex];\n\n          this._onWhenAddingFileFailed(temp, filter, options);\n        }\n      }\n    });\n\n    if (this.queue.length !== count) {\n      this._onAfterAddingAll(addedFileItems);\n\n      this.progress = this._getTotalProgress();\n    }\n\n    this._render();\n\n    if (this.options.autoUpload) {\n      this.uploadAll();\n    }\n  }\n\n  removeFromQueue(value) {\n    const index = this.getIndexOfItem(value);\n    const item = this.queue[index];\n\n    if (item.isUploading) {\n      item.cancel();\n    }\n\n    this.queue.splice(index, 1);\n    this.progress = this._getTotalProgress();\n  }\n\n  clearQueue() {\n    while (this.queue.length) {\n      this.queue[0].remove();\n    }\n\n    this.progress = 0;\n  }\n\n  uploadItem(value) {\n    const index = this.getIndexOfItem(value);\n    const item = this.queue[index];\n    const transport = this.options.isHTML5 ? '_xhrTransport' : '_iframeTransport';\n\n    item._prepareToUploading();\n\n    if (this.isUploading) {\n      return;\n    }\n\n    this.isUploading = true;\n    this[transport](item);\n  }\n\n  cancelItem(value) {\n    const index = this.getIndexOfItem(value);\n    const item = this.queue[index];\n    const prop = this.options.isHTML5 ? item._xhr : item._form;\n\n    if (item && item.isUploading) {\n      prop.abort();\n    }\n  }\n\n  uploadAll() {\n    const items = this.getNotUploadedItems().filter(item => !item.isUploading);\n\n    if (!items.length) {\n      return;\n    }\n\n    items.map(item => item._prepareToUploading());\n    items[0].upload();\n  }\n\n  cancelAll() {\n    const items = this.getNotUploadedItems();\n    items.map(item => item.cancel());\n  }\n\n  isFile(value) {\n    return isFile(value);\n  }\n\n  isFileLikeObject(value) {\n    return value instanceof FileLikeObject;\n  }\n\n  getIndexOfItem(value) {\n    return typeof value === 'number' ? value : this.queue.indexOf(value);\n  }\n\n  getNotUploadedItems() {\n    return this.queue.filter(item => !item.isUploaded);\n  }\n\n  getReadyItems() {\n    return this.queue.filter(item => item.isReady && !item.isUploading).sort((item1, item2) => item1.index - item2.index);\n  }\n\n  onAfterAddingAll(fileItems) {\n    return {\n      fileItems\n    };\n  }\n\n  onBuildItemForm(fileItem, form) {\n    return {\n      fileItem,\n      form\n    };\n  }\n\n  onAfterAddingFile(fileItem) {\n    return {\n      fileItem\n    };\n  }\n\n  onWhenAddingFileFailed(item, filter, options) {\n    return {\n      item,\n      filter,\n      options\n    };\n  }\n\n  onBeforeUploadItem(fileItem) {\n    return {\n      fileItem\n    };\n  }\n\n  onProgressItem(fileItem, progress) {\n    return {\n      fileItem,\n      progress\n    };\n  }\n\n  onProgressAll(progress) {\n    return {\n      progress\n    };\n  }\n\n  onSuccessItem(item, response, status, headers) {\n    return {\n      item,\n      response,\n      status,\n      headers\n    };\n  }\n\n  onErrorItem(item, response, status, headers) {\n    return {\n      item,\n      response,\n      status,\n      headers\n    };\n  }\n\n  onCancelItem(item, response, status, headers) {\n    return {\n      item,\n      response,\n      status,\n      headers\n    };\n  }\n\n  onCompleteItem(item, response, status, headers) {\n    return {\n      item,\n      response,\n      status,\n      headers\n    };\n  }\n\n  onCompleteAll() {\n    return void 0;\n  }\n\n  _mimeTypeFilter(item) {\n    var _a;\n\n    return !((item === null || item === void 0 ? void 0 : item.type) && this.options.allowedMimeType && ((_a = this.options.allowedMimeType) === null || _a === void 0 ? void 0 : _a.indexOf(item.type)) === -1);\n  }\n\n  _fileSizeFilter(item) {\n    return !(this.options.maxFileSize && item.size > this.options.maxFileSize);\n  }\n\n  _fileTypeFilter(item) {\n    return !(this.options.allowedFileType && this.options.allowedFileType.indexOf(FileType.getMimeClass(item)) === -1);\n  }\n\n  _onErrorItem(item, response, status, headers) {\n    item._onError(response, status, headers);\n\n    this.onErrorItem(item, response, status, headers);\n  }\n\n  _onCompleteItem(item, response, status, headers) {\n    item._onComplete(response, status, headers);\n\n    this.onCompleteItem(item, response, status, headers);\n    const nextItem = this.getReadyItems()[0];\n    this.isUploading = false;\n\n    if (nextItem) {\n      nextItem.upload();\n      return;\n    }\n\n    this.onCompleteAll();\n    this.progress = this._getTotalProgress();\n\n    this._render();\n  }\n\n  _headersGetter(parsedHeaders) {\n    return name => {\n      if (name) {\n        return parsedHeaders[name.toLowerCase()] || undefined;\n      }\n\n      return parsedHeaders;\n    };\n  }\n\n  _xhrTransport(item) {\n    // tslint:disable-next-line:no-this-assignment\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const that = this;\n    const xhr = item._xhr = new XMLHttpRequest();\n    let sendable;\n\n    this._onBeforeUploadItem(item);\n\n    if (typeof item._file.size !== 'number') {\n      throw new TypeError('The file specified is no longer valid');\n    }\n\n    if (!this.options.disableMultipart) {\n      sendable = new FormData();\n\n      this._onBuildItemForm(item, sendable);\n\n      const appendFile = () => sendable.append(item.alias, item._file, item.file.name);\n\n      if (!this.options.parametersBeforeFiles) {\n        appendFile();\n      } // For AWS, Additional Parameters must come BEFORE Files\n\n\n      if (this.options.additionalParameter !== undefined) {\n        Object.keys(this.options.additionalParameter).forEach(key => {\n          var _a, _b;\n\n          let paramVal = (_a = this.options.additionalParameter) === null || _a === void 0 ? void 0 : _a[key]; // Allow an additional parameter to include the filename\n\n          if (typeof paramVal === 'string' && paramVal.indexOf('{{file_name}}') >= 0 && ((_b = item.file) === null || _b === void 0 ? void 0 : _b.name)) {\n            paramVal = paramVal.replace('{{file_name}}', item.file.name);\n          }\n\n          sendable.append(key, paramVal);\n        });\n      }\n\n      if (appendFile && this.options.parametersBeforeFiles) {\n        appendFile();\n      }\n    } else {\n      if (this.options.formatDataFunction) {\n        sendable = this.options.formatDataFunction(item);\n      }\n    }\n\n    xhr.upload.onprogress = event => {\n      const progress = Math.round(event.lengthComputable ? event.loaded * 100 / event.total : 0);\n\n      this._onProgressItem(item, progress);\n    };\n\n    xhr.onload = () => {\n      const headers = this._parseHeaders(xhr.getAllResponseHeaders());\n\n      const response = this._transformResponse(xhr.response, headers);\n\n      const gist = this._isSuccessCode(xhr.status) ? 'Success' : 'Error';\n      const method = `_on${gist}Item`;\n      this[method](item, response, xhr.status, headers);\n\n      this._onCompleteItem(item, response, xhr.status, headers);\n    };\n\n    xhr.onerror = () => {\n      const headers = this._parseHeaders(xhr.getAllResponseHeaders());\n\n      const response = this._transformResponse(xhr.response, headers);\n\n      this._onErrorItem(item, response, xhr.status, headers);\n\n      this._onCompleteItem(item, response, xhr.status, headers);\n    };\n\n    xhr.onabort = () => {\n      const headers = this._parseHeaders(xhr.getAllResponseHeaders());\n\n      const response = this._transformResponse(xhr.response, headers);\n\n      this._onCancelItem(item, response, xhr.status, headers);\n\n      this._onCompleteItem(item, response, xhr.status, headers);\n    };\n\n    if (item.method && item.url) {\n      xhr.open(item.method, item.url, true);\n    }\n\n    xhr.withCredentials = item.withCredentials;\n\n    if (this.options.headers) {\n      for (const header of this.options.headers) {\n        xhr.setRequestHeader(header.name, header.value);\n      }\n    }\n\n    if (item.headers.length) {\n      for (const header of item.headers) {\n        xhr.setRequestHeader(header.name, header.value);\n      }\n    }\n\n    if (this.authToken && this.authTokenHeader) {\n      xhr.setRequestHeader(this.authTokenHeader, this.authToken);\n    }\n\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState == XMLHttpRequest.DONE) {\n        that.response.emit(xhr.responseText);\n      }\n    };\n\n    if (this.options.formatDataFunctionIsAsync) {\n      sendable.then(result => xhr.send(JSON.stringify(result)));\n    } else {\n      xhr.send(sendable);\n    }\n\n    this._render();\n  }\n\n  _getTotalProgress(value = 0) {\n    if (this.options.removeAfterUpload) {\n      return value;\n    }\n\n    const notUploaded = this.getNotUploadedItems().length;\n    const uploaded = notUploaded ? this.queue.length - notUploaded : this.queue.length;\n    const ratio = 100 / this.queue.length;\n    const current = value * ratio / 100;\n    return Math.round(uploaded * ratio + current);\n  }\n\n  _getFilters(filters) {\n    var _a, _b, _c;\n\n    if (!filters) {\n      return ((_a = this.options) === null || _a === void 0 ? void 0 : _a.filters) || [];\n    }\n\n    if (Array.isArray(filters)) {\n      return filters;\n    }\n\n    if (typeof filters === 'string') {\n      const names = filters.match(/[^\\s,]+/g);\n      return ((_b = this.options) === null || _b === void 0 ? void 0 : _b.filters) || [].filter(filter => (names === null || names === void 0 ? void 0 : names.indexOf(filter.name)) !== -1);\n    }\n\n    return ((_c = this.options) === null || _c === void 0 ? void 0 : _c.filters) || [];\n  }\n\n  _render() {\n    return void 0;\n  }\n\n  _queueLimitFilter() {\n    return this.options.queueLimit === undefined || this.queue.length < this.options.queueLimit;\n  }\n\n  _isValidFile(file, filters, options) {\n    this._failFilterIndex = -1;\n    return !filters.length ? true : filters.every(filter => {\n      if (this._failFilterIndex) {\n        this._failFilterIndex++;\n      }\n\n      return filter.fn.call(this, file, options);\n    });\n  }\n\n  _isSuccessCode(status) {\n    return status >= 200 && status < 300 || status === 304;\n  }\n\n  _transformResponse(response, headers) {\n    return response;\n  }\n\n  _parseHeaders(headers) {\n    const parsed = {};\n    let key;\n    let val;\n    let i;\n\n    if (!headers) {\n      return parsed;\n    }\n\n    headers.split('\\n').map(line => {\n      i = line.indexOf(':');\n      key = line.slice(0, i).trim().toLowerCase();\n      val = line.slice(i + 1).trim();\n\n      if (key) {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    });\n    return parsed;\n  }\n\n  _onWhenAddingFileFailed(item, filter, options) {\n    this.onWhenAddingFileFailed(item, filter, options);\n  }\n\n  _onAfterAddingFile(item) {\n    this.onAfterAddingFile(item);\n  }\n\n  _onAfterAddingAll(items) {\n    this.onAfterAddingAll(items);\n  }\n\n  _onBeforeUploadItem(item) {\n    item._onBeforeUpload();\n\n    this.onBeforeUploadItem(item);\n  }\n\n  _onBuildItemForm(item, form) {\n    item._onBuildForm(form);\n\n    this.onBuildItemForm(item, form);\n  }\n\n  _onProgressItem(item, progress) {\n    const total = this._getTotalProgress(progress);\n\n    this.progress = total;\n\n    item._onProgress(progress);\n\n    this.onProgressItem(item, progress);\n    this.onProgressAll(total);\n\n    this._render();\n  }\n\n  _onSuccessItem(item, response, status, headers) {\n    item._onSuccess(response, status, headers);\n\n    this.onSuccessItem(item, response, status, headers);\n  }\n\n  _onCancelItem(item, response, status, headers) {\n    item._onCancel(response, status, headers);\n\n    this.onCancelItem(item, response, status, headers);\n  }\n\n}\n\nlet FileSelectDirective = /*#__PURE__*/(() => {\n  class FileSelectDirective {\n    constructor(element) {\n      // eslint-disable-next-line @angular-eslint/no-output-on-prefix\n      this.onFileSelected = new EventEmitter();\n      this.element = element;\n    }\n\n    getOptions() {\n      var _a;\n\n      return (_a = this.uploader) === null || _a === void 0 ? void 0 : _a.options;\n    }\n\n    getFilters() {\n      return '';\n    }\n\n    isEmptyAfterSelection() {\n      return !!this.element.nativeElement.attributes.multiple;\n    }\n\n    onChange() {\n      var _a;\n\n      const files = this.element.nativeElement.files;\n      const options = this.getOptions();\n      const filters = this.getFilters();\n      (_a = this.uploader) === null || _a === void 0 ? void 0 : _a.addToQueue(files, options, filters);\n      this.onFileSelected.emit(files);\n\n      if (this.isEmptyAfterSelection()) {\n        this.element.nativeElement.value = '';\n      }\n    }\n\n  }\n\n  FileSelectDirective.ɵfac = function FileSelectDirective_Factory(t) {\n    return new (t || FileSelectDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  FileSelectDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FileSelectDirective,\n    selectors: [[\"\", \"ng2FileSelect\", \"\"]],\n    hostBindings: function FileSelectDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"change\", function FileSelectDirective_change_HostBindingHandler() {\n          return ctx.onChange();\n        });\n      }\n    },\n    inputs: {\n      uploader: \"uploader\"\n    },\n    outputs: {\n      onFileSelected: \"onFileSelected\"\n    }\n  });\n  return FileSelectDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FileUploadModule = /*#__PURE__*/(() => {\n  class FileUploadModule {}\n\n  FileUploadModule.ɵfac = function FileUploadModule_Factory(t) {\n    return new (t || FileUploadModule)();\n  };\n\n  FileUploadModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FileUploadModule\n  });\n  FileUploadModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return FileUploadModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { FileDropDirective, FileItem, FileLikeObject, FileSelectDirective, FileUploadModule, FileUploader }; //# sourceMappingURL=ng2-file-upload.mjs.map","map":null,"metadata":{},"sourceType":"module"}